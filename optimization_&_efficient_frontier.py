# -*- coding: utf-8 -*-
"""Optimization & Efficient Frontier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_wSOOFd-F4GNQtxml9pkGluaHqzBz0jY
"""

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from datetime import datetime, timedelta

# Section 1: Define Tickers and Time Range
tickers = ['SPY', 'BND', 'GLD', 'QQQ', 'VTI']
end_date = datetime.today()
start_date = end_date - timedelta(days=5*365)

# Section 2: Download Adjusted Close Prices
adj_close_df = pd.DataFrame()
for ticker in tickers:
    data = yf.download(ticker, start=start_date, end=end_date)
    adj_close_df[ticker] = data['Adj Close']

# Section 3: Calculate Lognormal Returns
log_returns = np.log(adj_close_df / adj_close_df.shift(1))
log_returns.dropna(inplace=True)

# Section 4: Calculate Covariance Matrix
cov_matrix = log_returns.cov() * 252

# Section 5: Define Portfolio Performance Metrics
def standard_deviation(weights, cov_matrix):
    variance = np.dot(weights.T, np.dot(cov_matrix, weights))
    return np.sqrt(variance)

def expected_return(weights, log_returns):
    return np.sum(log_returns.mean() * weights) * 252

def sharpe_ratio(weights, log_returns, cov_matrix, risk_free_rate):
    return (expected_return(weights, log_returns) - risk_free_rate) / standard_deviation(weights, cov_matrix)

# Section 6: Portfolio Optimization
risk_free_rate = 0.02

def neg_sharpe_ratio(weights, log_returns, cov_matrix, risk_free_rate):
    return -sharpe_ratio(weights, log_returns, cov_matrix, risk_free_rate)

constraints = {'type': 'eq', 'fun': lambda weights: np.sum(weights) - 1}
bounds = [(0, 0.4) for _ in range(len(tickers))]
initial_weights = np.array([1/len(tickers)]*len(tickers))

optimized_results = minimize(neg_sharpe_ratio, initial_weights, args=(log_returns, cov_matrix, risk_free_rate), method='SLSQP', constraints=constraints, bounds=bounds)

# Section 7: Analyze the Optimal Portfolio
optimal_weights = optimized_results.x

print("Optimal Weights:")
for ticker, weight in zip(tickers, optimal_weights):
    print(f"{ticker}: {weight:.4f}")

optimal_portfolio_return = expected_return(optimal_weights, log_returns)
optimal_portfolio_volatility = standard_deviation(optimal_weights, cov_matrix)
optimal_sharpe_ratio = sharpe_ratio(optimal_weights, log_returns, cov_matrix, risk_free_rate)

print(f"Expected Annual Return: {optimal_portfolio_return:.4f}")
print(f"Expected Volatility: {optimal_portfolio_volatility:.4f}")
print(f"Sharpe Ratio: {optimal_sharpe_ratio:.4f}")

# Display the Final Portfolio in a Plot
plt.figure(figsize=(10, 6))
plt.bar(tickers, optimal_weights, color='blue')

plt.xlabel('Assets')
plt.ylabel('Optimal Weights')
plt.title('Optimal Portfolio Weights')
plt.xticks(rotation=45)
plt.show()

# Section 8: Simulate Random Portfolios
num_portfolios = 10000
all_weights = np.zeros((num_portfolios, len(tickers)))
ret_arr = np.zeros(num_portfolios)
vol_arr = np.zeros(num_portfolios)
sharpe_arr = np.zeros(num_portfolios)

for ind in range(num_portfolios):
    weights = np.array(np.random.random(len(tickers)))
    weights = weights / np.sum(weights)

    all_weights[ind, :] = weights
    ret_arr[ind] = expected_return(weights, log_returns)
    vol_arr[ind] = standard_deviation(weights, cov_matrix)
    sharpe_arr[ind] = (ret_arr[ind] - risk_free_rate) / vol_arr[ind]

# Plotting the Efficient Frontier
plt.figure(figsize=(12, 8))
plt.scatter(vol_arr, ret_arr, c=sharpe_arr, cmap='viridis')
plt.colorbar(label='Sharpe Ratio')
plt.xlabel('Volatility')
plt.ylabel('Return')
plt.title('Efficient Frontier with Optimal Portfolio')

# Highlighting the Optimal Portfolio
max_sharpe_idx = sharpe_arr.argmax()
plt.scatter(vol_arr[max_sharpe_idx], ret_arr[max_sharpe_idx], color='r', s=50, edgecolors='black') # Optimal Portfolio

# Capital Market Line
cml_x = [0, vol_arr[max_sharpe_idx]]
cml_y = [risk_free_rate, ret_arr[max_sharpe_idx]]
plt.plot(cml_x, cml_y, color='black', linestyle='--', linewidth=2, label='Capital Market Line')

plt.legend(labelspacing=0.8)
plt.show()

# Conclusion
# This script demonstrates how to optimize a portfolio to achieve the best risk-adjusted return using MPT.